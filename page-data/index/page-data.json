{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"Tory","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"Diameter of Tree 문제 가중치를 가지는 트리에서 임의의 두 노드를 선택합니다. 이 때 두 노드를 연결하는 가중치들의 합이 최대가 되는 가중치를 반환하세요.(지름 반환 문제) 접근방법 임의의 두 리프 노드를 선택한 집합이 최장 가중치의 후보가 된다. 루트 노드에서 부터 1 depth씩 내려가며 가장 긴 간선을 택해 리프 노드를 찾아가는 Gree…","fields":{"slug":"/Problem Solving/트리의-지름/"},"frontmatter":{"date":"April 15, 2021","title":"트리의 지름","category":"problem solving","draft":false}}},{"node":{"excerpt":"추상자료형이란? 값이나 연산의 집합으로 정의되는 자료형의 수학적 모델. 특징 ADT만 알고있다면 하나의 ADT로 부터 구현된 여러개의 자료구조들을 ADT에 정의된 방법으로 동일하게 사용할 수 있다. ex) ADT:List, DS: ArrayList, LinkedList) 또한 동일한 결과를 보여주는 두 자료구조라도 내부 구현방식은 다를 수 있기 때문에, …","fields":{"slug":"/Data Structure/abstract-data-type/"},"frontmatter":{"date":"April 12, 2021","title":"Abstract Data Type","category":"data structure","draft":false}}},{"node":{"excerpt":"세상을 바꾸는 시간, 15분 이명수 선생님의 강연을 듣고… 이 글은 건강한 마음으로 공부하기 위해  라는 목적을 가지고 작성했습니다. 패스트캠퍼스 네카라쿠배 프론트엔드 스쿨 1기 - 3주차 많이 어렵고 이해하기 힘들었던 자료구조&알고리즘 수업이 어제로 끝났다. 라고 생각할 정도로 정말 많은 양을 공부했다. 내가 이 수업을 놓치지 않고 따라갈수 있던 이유는…","fields":{"slug":"/diary/느리게-걷기-대회/"},"frontmatter":{"date":"April 10, 2021","title":"느리게 걷기 대회","category":"diary","draft":false}}},{"node":{"excerpt":"동적계획법이란 두 가지 조건을 포함해서 복잡한 문제를 보다 단순한 부분 문제로 나누어 해결하는 방법입니다. 부분문제들의 최적해가 전체의 최적해를 이룹니다. 동일한 부분문제들이 여러번 발생합니다. 조건이 충족되지 않으면 분할&정복 문제라고 합니다. 동적계획법의 핵심 중복되는 연산을 미리 캐싱해 두고, 중복 연산이 발생할 때 마다 참조하여 연산을 줄입니다. …","fields":{"slug":"/algorithm/dynamic-programming/"},"frontmatter":{"date":"April 07, 2021","title":"Dynamic Programming","category":"algorithm","draft":false}}},{"node":{"excerpt":"문제 도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다. 각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다. 각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를…","fields":{"slug":"/Problem Solving/burglary/"},"frontmatter":{"date":"April 07, 2021","title":"burglary","category":"Problem Solving","draft":false}}},{"node":{"excerpt":"Today I learned 오늘은 max-width 속성에 대해 알아보았다.\nmax-width 속성은 inline, block 요소와 무관하게\n모든 요소에 대해서 width 값의 maximum을 설정한다. inline요소와 block요소에 따른 차이점은\nblock 요소는 기본적으로 가로를 모두 채우고있기 때문에 width에 여백이 생긴 경우라면 남은 여…","fields":{"slug":"/html/til210406/"},"frontmatter":{"date":"April 06, 2021","title":"TIL210406","category":"html","draft":false}}},{"node":{"excerpt":"Jump into BST 이진트리 구조에 특수한 규칙을 적용한 트리입니다. 부모 노드를 기준으로 왼쪽 자식 노드에는 작은 값의 노드가 삽입되고, 오른쪽 자식 노드에는 큰 값이 삽입 됩니다. Basic aspects of BST: 좌우의 균형이 맞으면, 탐색, 삽입, 제거의 시간복잡도가 log(n)으로 상당히 빠른 편에 속한다. 삽입되는 순서에 따라 트리가…","fields":{"slug":"/Data Structure/binary-search-tree/"},"frontmatter":{"date":"April 05, 2021","title":"Binary Search Tree","category":"Data Structure","draft":false}}},{"node":{"excerpt":"Jump to Merge Sort About Merge Sort 정렬된 두 리스트의 왼쪽 인덱스부터 차례대로 대소관계를 비교합니다. 그리고 비교된 값 중 작은 값 부터 새로운 리스트에 채워나가면 O(n)의 시간복잡도로 두 리스트를 하나의 리스트에 정렬시킬 수 있습니다. 이 방법을 활용해서 정렬되지 않은 하나의 리스트를 길이가 2 혹은 1인 여러 개의 부분…","fields":{"slug":"/algorithm/merge-sort/"},"frontmatter":{"date":"April 05, 2021","title":"Merge Sort","category":"algorithm","draft":false}}},{"node":{"excerpt":"Jump into Binary Search 정렬된 자료에서 탐색하는 알고리즘입니다.\n나열된 자료들 중에서 중앙에 있는 값을 기준으로 찾고자 하는 값이 큰 경우 혹은 작은 경우에 따라 찾아야 하는 자료의 범위가 반씩 줄어들기 때문에 시간 복잡도는 O(logN)이 됩니다. 1. 구현 첫번째 구현(recursion) 두번째 구현(iteration)","fields":{"slug":"/algorithm/binary-search/"},"frontmatter":{"date":"April 04, 2021","title":"Binary Search","category":"algorithm","draft":false}}},{"node":{"excerpt":"Jump to Complexity 1. Algorithm 알고리즘이란 문제를 해결하기 위한 여러 동작들의 모임입니다. 서로 다른 두 개의 알고리즘이 같은 결과를 출력할지라도 소비되는 컴퓨터의 메모리와, 출력까지 소요되는 시간은 달라지게 됩니다. 즉, 메모리와 시간이 알고리즘을 측정할 수 있는 기준이 됩니다. 2. Complexity 알고리즘이 어떤 문제를…","fields":{"slug":"/algorithm/time-complexity/"},"frontmatter":{"date":"April 04, 2021","title":"Time Complexity","category":"algorithm","draft":false}}},{"node":{"excerpt":"Jump to Insertion Sort 1. About Insertion Sort 삽입 정렬은 가장 기본적인 정렬 알고리즘 중에 하나입니다.\n기본적으로 정렬되지 않은 부분과 정렬된 부분으로 나눌 수 있습니다. 우선 정렬되지 않는 부분을 순차적으로 순회합니다. 이 때 각 데이터가 정렬된 부분의 어느 위치에 삽입되어야 정렬 상태를 유지하는지 찾아내고 삽입합…","fields":{"slug":"/algorithm/insertion-sort/"},"frontmatter":{"date":"April 04, 2021","title":"Insertion Sort","category":"algorithm","draft":false}}},{"node":{"excerpt":"Jump to Quick Sort 🚴 1. About Quick Sort 퀵 정렬은 분할1과 정복2을(Divide and conquer) 적극적으로 활용한 정렬 알고리즘이다. 퀵 정렬은 PIVOT이라는 기준값이 존재한다. 이 PIVOT을 기준으로 작은 값의 범위, 큰 값의 범위로 나누는 분할&정복 과정을 반복하는 알고리즘이다. 2. Code case1: …","fields":{"slug":"/algorithm/quick-sort/"},"frontmatter":{"date":"April 03, 2021","title":"Quick Sort","category":"algorithm","draft":false}}},{"node":{"excerpt":"Getting Started 😎 1. Create a Gatsby site. If you are not using , following Gatsby Getting Started 2. Start developing. 3. Add your content You can write… contents to blog in  directory. resume  dire…","fields":{"slug":"/development/quick_start/"},"frontmatter":{"date":"July 05, 2020","title":"Quick Start","category":"development","draft":false}}}]}},"pageContext":{}},"staticQueryHashes":["3128451518","521680639"]}